\documentclass[a4paper,11pt]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{titlesec}
\usepackage{exptech}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{color}

% Pour les figures
\usepackage{pstricks}
\usepackage{epsfig}
\usepackage[justification=centering]{caption}
\usepackage{tikz}

\setlength{\parskip}{1em}
% Random code from stackoverflow refining chapters
% See http://tex.stackexchange.com/questions/110840/how-to-remove-chapter-numbering-without-removing-it-from-tableofcontents
\titleformat{\chapter}
  {\Large\bfseries} % format
  {}                % label
  {0pt}             % sep
  {\huge}           % before-code

%% ** Begin document ** %%

\title{Étude pratique : Amélioration de la complétion automatique de \LaTeX{}ila}
\author{Axel Caro\and François Bochet\and Maximilien Richer}
\date{2014-2015}

\begin{document}

% Configuration pour le code
\include{./lst_config}

\maketitle %affichage du titre
\tableofcontents %table des matières
\newpage

\clearpage
\vspace*{\fill}

\section*{\centerline{Remerciements}} % (fold)
\begin{center}
\label{sec:remerciements}
Nous remercions Arnaud Blouin (IRISA/INSA), notre encadrant, pour sa disponibilité et ses conseils, ainsi que Sébastien Wilmet, développeur et mainteneur de Latexila, pour sont aide.
\end{center}

\vfill
\clearpage


\chapter{Introduction}
\label{cha:Introduction}
Les \textit{études pratiques} sont des projets réalisés chaque année pas les élèves du département Informatique de l'INSA de Rennes.

Elles s'étalent sur toute la durée de l'année scolaire et visent à permettre aux étudiants de développer leur sens du travail en équipe ainsi que leur autonomie.
Les sujets sont aussi divers que variés, allant de prototypes applicatifs aux sites web, en passant par les réalisations d'IA.

Cette étude pratique en particulier se présente sous la forme d'une contribution à un logiciel dont le code source est libre, c'est à dire qu'il est mis à disposition du public qui peut s'il le souhaite proposer des améliorations.

\section{Latexila}
\label{sec:latexila}
Latexila est un projet d'éditeur LaTeX pour le projet Gnome, dont le développement a commencé en 2009\footnote{Voir \url{https://wiki.gnome.org/Apps/LaTeXila/History}} à l'initiative de Sébastien Wilmet, qui est encore à ce jour le mainteneur du projet.
Bien que commencé en C, le projet a été porté vers le langage Vala en 2010. LaTeXiLa adopte une approche centrée sur le code, ce qui lui permet d'être bien plus léger que nombre d'autres éditeurs, comme TeXMaker\footnote{\url{http://www.xm1math.net/texmaker/index_fr.html}} par exemple.

De par cette philosophie, il ne possède pas de module WYSIWYG\footnote{What You See Is What You Get - Un mode d'édition ou l'utilisateur édite directement une vue correspondant au rendu final}, ce qui le rend moins facile d'accès.
Il met cepandant à la disposition de l'utilisateur des outils puissant qui en font bien plus qu'un simple éditeur de texte, comme:

\begin{itemize}
	\item Compilation assistée
	\item Gestion de projet simplifiée
	\item Complétion à la saisie des commandes \LaTeX
\end{itemize}
\newpage

\subsection{À propos de \LaTeX}
\LaTeX  est un langage bien connu de la communauté scientifique, utilisé pour la composition de documents.
Il permet notamment de mettre en place des feuilles de style normalisées, ou encore de construire des expressions mathématiques.
Ce document a été écrit en \LaTeX.
% write something here ?

\subsection{Le langage Vala}
\label{sub:vala}
Vala\footnote{\textit{\url{https://wiki.gnome.org/Projects/Vala/About}}} est un langage développé pour le projet Gnome.
Il vise à être une alternative au C\# et au Java, en proposant une syntaxe puissante orientée objet.
Il se base sur la librairie GObject et est compilé en C via la commande \texttt{valac}.

\begin{figure}[h] % TODO réduire l'espacement
\begin{lstlisting}
int main (string[] args) {

    // Output the number of arguments
    stdout.printf ("%d command line argument(s):\n", args.length);

    // Enumerate all command line arguments
    foreach (string arg in args) {
        stdout.printf ("%s\n", arg);
    }

    // Exit code (0: success, 1: failure)
    return 0;
}
\end{lstlisting}
\caption{"Command-Line Arguments and Exit Code" en Vala, tiré de \url{wiki.gnome.org/Projects/Vala/BasicSample}}
\end{figure}
\section{Compiler LaTeXila}
\label{cha:compiler}
La compilation d'un projet GNOME est un processus complexe pour un non-initié.
L'obtention de paquets en pré-série souvent non stables est déconseillée pour les non-développeurs du fait de leur stabilité toute relative.
On utilise donc des outils spécifiques de manière à séparer environnement utilisateur et environnement de test. 

\subsection{Jhbuild}
\label{sub:jhbuild}
JHBuild est un outil conçu pour permettre au développeur de construire les librairies d'un projet dans un environnement bac-à-sable, de manière à éviter une instabilité de la machine de développement causée par l'utilisation de librairies en pré-version.

Il fournit certaines commandes très utiles, telles que :

\begin{figure}[h]
\begin{tabular}{|l|l|}
  \hline \texttt{jhbuild update <package>} & Met à jour le paquet et toutes ses dépendances. \\
  \hline \texttt{jhbuild build <package>} & Met à jour et compile paquet et dépendances. \\
  \hline \texttt{jhbuild buildone <package>} & Ne compile que le paquet ciblé. \\
  \hline \texttt{jhbuild make <target>} & Exécute le Makefile à l'emplacement courant. \\
  \hline
\end{tabular}
\caption{Utilisation de JHBuild}
\end{figure}

Ainsi, un \textit{jhbuild build latexila} réalise, pour chaque dépendances de latexila un \textit{checkout} sur la branche master du dépôt, suivi d'un \textit{fetch} puis d'un \textit{rebase} suivi de l'exécution d'un \textit{make all}.

Dans le cas de la compilation d'une version de test, on utilisera \textit{jhbuild make}, qui nous permettra de compiler sur la branche courante.
% à développer

\chapter{Étude pratique} % (fold)
\label{cha:etude_pratique}
Le but de cette étude pratique est d'ajouter à la complétion le support de la commande \textbf{\textbackslash{}ref} qui proposerait comme complétion une liste des clef des \textbf{\textbackslash{}label}.

\section{Tâche à réaliser} % (fold)
\label{sec:tache_a_realiser}
La tâche à réaliser est l'amélioration de la complétion des commande de références. Il existe un système déjà en place, celui-ci doit donc être amélioré.

\subsection{La complétion dans LaTeXila 2.2}
\label{sub:completion}
La version 2.2 de Latexila fournit une complétion exhaustive des éléments statiques du langage \LaTeX~se basant sur un fichier XML descriptif lu au démarrage du programme.
Cette complétion est donc dite \textit{statique}, car elle ne s'adapte pas au contenu précédemment tapé par l'utilisateur. Cette complétion propose :

\begin{description}
  \item[Fonction] de la forme \textbackslash\textit{fonction}\{argument\}, défini par \LaTeX
  \item[Argument] peut être définit par \LaTeX~ou tiré de l'environnement utilisateur\footnote{non pris en charge car nécéssite une complétion dynamique}
\end{description}

\subsection{Une complétion dynamique}
\label{sub:completion_dyn}
Afin d'améliorer ce mécanisme de complétion pour qu'il prenne en charge l'argument de la commande \textbf{\textbackslash{}ref}, il convient de lui adjoindre une composante \textit{dynamique}, qui prendra en compte les éléments \textbf{\textbackslash{}label} déclarés par l'utilisateur.
% section tâche_à_réaliser (end)

\section{Gestion de projet} % (fold)

\subsection{Git}
\label{sub:git}
Git est le VCS\footnote{Version Control System} utilisé par la très grande majorité des projets open-source. LaTeXiLa est hébergé sur le dépôt git du projet Gnome\footnote{\url{git.gnome.org}}  et un miroir est également disponible sur Github\footnote{\url{https://github.com/GNOME/latexila}}.
Pour ce projet, nous avons créé un \textit{fork} du dépôt principal sur Github et travaillé sur une branche annexe, régulièrement mise à jour à partir du dépôt pricipal.
Un patch entre la \textbf{branche principale} et la \textbf{branche de test} est ensuite créé avec \texttt{git patch} et posté sur le bugzilla du projet.

\subsection{Bugzilla}
Les soumissions\footnote{Propositions de contribution au projet} sont faites via le Bugzilla du projet Gnome.
Bugzilla\footnote{\url{www.bugzilla.org}} est une plateforme de suivi de bug gratuite et libre, qui a vocation à faciliter la collaboration entre les développeurs.

Une soumission de bug sur la plateforme du projet donne lieu à une page dédiée\footnote{Exemple de la page de ce projet \url{https://bugzilla.gnome.org/show_bug.cgi?id=748069}}, ce qui permet au mainteneur de commenter le rapport d'incident et le code soumis.
Il s'ensuit ensuite un va-et-vient entre le mainteneur et le développeur jusqu'à la fusion du patch dans la branche principale du projet.

\chapter{Réalisation}
La réalisation s'est faite par petits pas. Sur une base de deux semaines de travail, l'équipe se donnait un objectif à atteindre pour le point suivant avec l'encadrant.
Ces points bi-mensuels permettaient de discuter des directions à prendre pour le développement.

\section{Intégration d'une recherche au document courant}
Notre premier objectif a été de récupérer l'ensemble des labels déclarés dans le document courant.

Après avoir analysé le code, nous avons décidé d'utiliser tout d'abord un parseur existant, celui permettant de construire l'arbre représentatif de la structure du document.
Ces résultats sont ensuite intégrés au \textit{Completion Provider}, classe utilisée jusqu'alors pour gérer la complétion statique, et mis à jour lors de l'ouverture et de la sauvegarde du document.

% Le diagramme de fonctionnement du parser
\begin{figure}[h]
\label{fig:doc_opening}
\centering
\include{./draw/doc_opening}
\caption{Diagramme de séquence d'une analyse de document}
\end{figure}

\subsection{Invite de complétion}
%Le diagramme UML de la structure de completion
\begin{figure}[h!]
\label{fig:uml_completion_structure}
\centering
\include{./draw/uml_completion_structure}
\caption{Le diagramme UML de la structure de completion.}
\end{figure}

À ce stade, la complétion prend en charge le document courant, mais l'utilisation du parseur déjà existant implique certaines contraintes, celle de ne pas pouvoir l'appeler quand on le souhaite.
La mise à jour de la complétion se fait donc en même temps que celle de l'arbre représentant la structure du document courant. 
Ainsi lors du changement de document, par exemple, la complétion n'est pas mise à jour et n'est donc pas pertinente.
D'autre part, on perd les précédentes données de complétion lors du parsage d'un autre document.
Conserver ces données éviterai des parsage redondants et permettrait d'économiser du temps de calcul.

\section{Intégration d'une recherche à plusieurs documents}
L'étape suivante a été l'intégration de la complétion pour tous les documents ouverts dans LaTeXiLa, permettant ainsi de proposer une complétion propre à chaque document et d'éviter les propositions inappropriées.
Problèmes : comment choisir parmis les propositions celles liée au document courant ? Et comment stoker ces différents ensembles de choix de complétion de manière à pouvoir les mettre à jour ?

Ceci nous a conduit à rechercher une structure de donnée adaptée, et à l'implémenter après avoir étudié la documentation de ces structures dans le langage vala.
Nous avons opté pour l'ajout d'une table de hachage au \textit{CompletionProvider}, qui stokera les ensemble de choix de complétion, indexés par le chemin absolu du fichier .tex auquel ils correspondent.

%Le diagramme de séquence d'une demande de complétion
\begin{figure}[h]
\label{fig:filtering_completion}
\centering
\include{./draw/filtering_completion}
\caption{Diagramme de séquence d'une demande de complétion.}
\end{figure}

Les choix de complétion proposés à l'utilisateur sont ceux du document courant.
Ceux-ci sont mis à jour lors de l'appel de l'utilisateur au gestionnaire de complétion. Ainsi, même lors du changement de document, ces choix sont filtrés pour le nouveau document.

À ce stade, la complétion est fonctionnelle pour tous les fichiers ouverts, les données ne sont pas perdues, leur mise à jour est cohérente, et la mise à jour des choix de complétion du gestionnaire de complétion est faite de façon efficace (mise à jour uniquement si nécessaire, donc si l'utilisateur change de document, ou s'il sauvegarde un document).
Cependant, il reste des problèmes : les choix de complétion ne contiennent que les labels déclarés dans le document courant, alors que le principe du langage \LaTeX{} est de permettre les références entre documents.
Il faut donc revoir le filtrage des choix de complétion.
Cet aspect nous conduit également à proposer des choix de complétion provenant de documents qui n'ont pas été ouverts.

\section{Intégration des fichiers non-ouverts}
Après discussion avec notre encadrant, nous avons décidé de limiter les choix de complétion pour un document à l'ensemble des labels déclarés dans les documents .tex de son répertoire.
Ce point est sujet à discussion, et nous y reviendrons par la suite.
Nous nous sommes donc intéressés à la notion de fichier en vala, et à leur manipulation.
Les données sont désormais filtrées sur le chemin absolu du répertoire parent du document courant.
D'autre part, nous avons décidé de dissocier le parseur des labels du parseur de la structure du document, séparant ainsi ces deux aspects distincts.

%Le diagramme de séquence d'une analyse enarrière plan
\begin{figure}[h]
\label{fig:multiple_doc_completion}
\centering
\include{./draw/multiple_doc_completion}
\caption{Diagramme de séquence d'analyse en arrière plan.}
\end{figure}

À ce stade, la complétion est entièrement fonctionnelle.
Les choix proposés sont les labels déclarés dans les documents .tex du même répertoire que le document courant, l'analyse des documents est faite uniquement au besoin, et le changement de document courant vers un document d'un autre répertoire est fonctionnel.

\chapter{Conclusion}
Le mécanisme de complétion, auparavant \textit{statique} prend désormais en charge une complétion \textit{dynamique} sur les labels déclarés par l'utilisateur.
Cependant, notre solution est notamment criticable sur le point suivant : le filtrage des choix de complétion proposés, sur le répertoire parent du document courant.
En effet, certains utilisateurs sont susceptibles d'utiliser des sous-répertoires pour organiser leurs fichiers, et ne bénéficieraient donc pas de la complétion souhaitée.
De plus, il arrive que certains fichiers .tex ne soient que des anciennes versions de rapports, voire des fichiers de tests. Dans ce cas, notre mécanisme de complétion proposerait les labels déclarés dans ces fichiers, alors qu'ils ne sont pas souhaités.

Nous avons tout de même soumis ce patch au mainteneur du projet, monsieur Wilmet, qui nous a fait part de ses commentaires.

Après discussion avec notre encadrant et monsieur Wilmet, nous avons établi que pour palier à ces problèmes, une refonte de la notion de \textit{projet} comme ils sont organisés dans LaTeXiLa était nécessaire.
On pourrait ainsi proposer une complétion ne prenant en compte que les fichiers faisant partie du même projet, et éviter les points précédemment soulevés.

Cette étude pratique a été pour nous l'occasion de découvrir le fonctionnement des projets open-source.

\end{document}
