\documentclass[a4paper,11pt]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{titlesec}
\usepackage{exptech}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{color}

% Pour les figures
\usepackage{pstricks}
\usepackage{epsfig}

\usepackage{tikz}

%% ** Begin document ** %%

\title{Étude pratique : Amélioration de la complétion automatique de \LaTeX{}ila}
\author{Axel Caro\and François Bochet\and Maximilien Richer}
\date{2014-2015}

\begin{document}

% Configuration pour le code
\include{./lst_config}

\maketitle %affichage du titre
\tableofcontents %table des matières

\section{Remerciements} % (fold)
\label{sec:remerciements}
Nous remercions Arnaud Blouin, notre encadrant, pour sa disponibilité et ses conseils, ainsi que Sébastien Wilmet, développeur et mainteneur de LaTeXila.

\chapter{Introduction}
\label{cha:Introduction}
Les \textit{études pratiques} sont des projets réalisés chaque année pas les élèves du département Informatique de l'INSA de Rennes. Ils s'étalent sur toute la durée de l'année scolaire et visent à permettre aux étudiants de développer leur sens du travail et équipe et leur autonomie. Les sujets sont aussi divers que variés, allant de prototypes applicatifs au site web, en passant par les réalisations d'IA.

Cette étude pratique en particulier se présente sous la forme d'une contribution à un logiciel dont le code source est ouvert\footnote{Logiciel dit "open-source"}, c'est à dire qu'il est mis à disposition du public pour modification.

\section{Latexila}
\label{sec:latexila}
Latexila est un projet d'éditeur LaTeX pour le projet Gnome, dont le développement a commencé en 2009 à l'initiative de Sébastien Wilmet, qui est encore à ce jour le mainteneur du projet. Bien que commencé en C, le projet a été porté vers le langage Vala en 2010. LaTeXiLa adopte une approche centrée sur le code, ce qui lui permet d'être bien plus léger que nombre d'autres éditeurs, comme TeXMaker\footnote{\url{http://www.xm1math.net/texmaker/index_fr.html}} par exemple. De par cette philosophie, il ne possède pas de module WYSIWYG\footnote{What You See Is What You Get - Un mode d'édition ou l'utilisateur édite directement une vue correspondant au rendu final}.

%\include{./draw/UI}

%see more @https://wiki.gnome.org/Apps/LaTeXila/History

\subsection{À propos de \LaTeX}
LaTeX est un langage bien connu de la communauté scientifique, utilisé pour la composition de documents. Il permet notamment de mettre en place des feuilles de style normalisées, ou encore de construire des expressions mathématiques.
% write something here ?

\subsection{Le langage Vala}
\label{sub:vala}
Vala est un langage développé pour le projet Gnome. Il vise à être une alternative au C\# et au Java, en proposant une syntaxe puissante pour la programmation orientée objet. Il se base sur la librairie GObject et est compilé en C via la commande `valac`.
% more @ https://wiki.gnome.org/Projects/Vala/About
\begin{lstlisting} % TODO encadrer

void main () {
    print ("hello, world\n");
}

\end{lstlisting}\textit{Exemple tiré de wiki.gnome.org/Projects/Vala/BasicSample}

\section{Compiler LaTeXila}
\label{cha:compiler}
La compilation d'un projet GNOME est un processus complexe pour un non-initié. L'obtention de paquets en pré-série souvent non stables est déconseillée pour les non-développeurs du fait de leur stabilité toute relative. On utilise donc des outils spécifiques de manière à séparer environnement utilisateur et environnement de test. 

\subsection{Jhbuild}
\label{sub:jhbuild}

\begin{quote}
JHBuild allows you to build and run Gnome platform and applications building the required modules in a sandbox environment, isolating the installation ; so there is no need to build and run Gnome inside a virtual machine. \textit{\url{wiki.gnome.org}}
\end{quote}

Comme indiqué ci-dessus, il s'agit d'un outil conçu pour permettre au développeur de construire les librairies d'un projet dans un environnement bac-à-sable, de manière à éviter une instabilité de la machine de développement causée par l'utilisation de librairies en pré-version. Il fournit certaines commandes très utiles, telles que :

\begin{description}
  \item[jhbuild update <package>] Met à jour le paquet et toutes ses dépendances.
  \item[jhbuild build <package>] Met à jour et compile le paquet et toutes ses dépendances.
  \item[jhbuild buildone <package>] Ne compile que le paquet ciblé.
  \item[jhbuild make <target>] Exécute le Makefile à l'emplacement courant.
\end{description}

Ainsi, un \textit{jhbuild build latexila} réalise, pour chaque dépendances de latexila :

\begin{description} 
  \item[Mise à jour] Un \textit{checkout} sur la branche master du dépôt, suivi d'un \textit{fetch} puis d'un \textit{rebase}.
  \item[Compilation] Exécution du \textit{make all}.
\end{description}

Dans le cas de la compilation d'une version de test, on utilisera \textit{jhbuild make}, qui nous permettra de compiler sur la branche courante.
% à développer

\chapter{Étude pratique} % (fold)
\label{cha:etude_pratique}
Le but de cette étude pratique est d'ajouter à la complétion le support de la commande \textbf{\\ref} qui proposerait comme complétion une liste des clef des \\label.

\section{Tâche à réaliser} % (fold)
\label{sec:tache_a_realiser}
La tâche à réaliser est l'amélioration de la complétion des commande de références. Il existe un système déjà en place, celui-ci doit donc être amélioré.

\subsection{La complétion dans LaTeXila 2.2}
\label{sub:completion}
La version 2.2 de LaTeXiLa fournit une complétion exhaustive des éléments statiques du langage \LaTeX  en se basant sur un fichier XML descriptif lu au démarrage du programme.
Cette complétion est donc dite \textit{statique}, car elle ne s'adapte pas au contenu précédemment tapé par l'utilisateur. 

\begin{description}
  \item[Fonction] de la forme \\\textit{fonction}\{argument\}, défini par \LaTeX
  \item[Argument] peut être définit par \LaTeX  ou tiré de l'environnement utilisateur
\end{description}

\subsection{Une complétion dynamique}
\label{sub:completion_dyn}
Afin d'améliorer ce mécanisme de complétion pour qu'il prenne en charge la commande \textbf{\\ref}, il convient donc de lui adjoindre une composante \textit{dynamique}, qui prendra en compte les éléments \\label déclarés par l'utilisateur.
% section tâche_à_réaliser (end)

\section{Gestion de projet} % (fold)

\subsection{Git}
\label{sub:git}
Git est le VCS\footnote{Version Control System} utilisé par la très grande majorité des projets open-source. LaTeXiLa est hébergé sur le dépôt du projet Gnome\footnote{\url{git.gnome.org}}, un miroir est également disponible sur Github % adresse 
Pour ce projet, nous avons créé un \textit{fork} du dépôt principal sur Github et travaillé sur une branche annexe, régulièrement mise à jour à partir du dépôt pricipal.

\subsection{Bugzilla}
Les soumissions sont faites via le Bugzilla du projet Gnome. % expliquer soumission
Bugzilla\footnote{\url{www.bugzilla.org}} est une plateforme de suivi de bug gratuite et libre, qui a vocation à faciliter la collaboration entre les développeurs.
Une soumission de bug sur la plateforme du projet donne lieu à une page dédiée\footnote{Exemple de la page de ce projet \url{https://bugzilla.gnome.org/show_bug.cgi?id=748069}}, ce qui permet au mainteneur de commenter le rapport d'incident et le code soumis.
Il s'ensuit ensuite un va-et-vient entre le mainteneur et le développeur jusqu'à la fusion du patch dans la branche principale du projet.

\chapter{Réalisation}
La réalisation s'est faite par petits pas. Sur une base de deux semaines de travail, l'équipe se donnait un objectif à atteindre pour le point suivant avec l'encadrant.
Ces points bi-mensuels permettaient de discuter des directions à prendre pour le développement.

\section{Intégration d'une recherche au document courant}
Notre premier objectif a été de récupérer l'ensemble des \\label déclarés dans le document courant. Après avoir analysé le code, nous avons décidé d'utiliser tout d'abord un parseur existant, celui permettant de construire l'arbre représentatif de la structure des documents.

% Le diagramme de fonctionnement du parser
\begin{figure}[h]
\label{fig:flow_parser_call}
\centering
\include{./draw/flow_parser_call}
\caption{L'appel au parser.}
\end{figure}

Ces résultats sont ensuite intégrés au \textit{Completion Provider} (classe utilisée jusqu'alors pour gérer la complétion statique).

\subsection{Invite de complétion}

\begin{lstlisting}[frame=single]
public class CompletionProvider : GLib.Object, SourceCompletionProvider
{
    // Structure de la commande
    struct CompletionCommand
    {
        string name;    // Dans notre cas, la commande \\ref
        string? package;
        CompletionArgument[] args;  // Dans notre cas, un seul argument
    }
    // Structure d'argument de commande
    struct CompletionArgument
    {
        string label;
        bool optional;
        CompletionChoice[] choices; // Dans notre cas, l'ensemble des labels déclarés par l'utilisateur
    }
    // Structure de la proposition de complétion
    public struct CompletionChoice
    {
        string name;    // Dans notre cas, l'intitulé du label
        string? package;
        string? insert;
        string? insert_after;
    }
\end{lstlisting}

%Le diagramme UML de la structure de completion
\begin{figure}[h!]
\label{fig:uml_completion_structure}
\centering
\include{./draw/uml_completion_structure}
\caption{Le diagramme UML de la structure de completion.}
\end{figure}

À ce stade, la complétion est fonctionnelle pour le document courant, mais l'utilisation du parseur déjà existant implique certaines contraintes. La mise à jour de la complétion se fait en même temps que celle de l'arbre représentant la structure du document courant, alors qu'il s'agit de deux traitement à priori indépendants. Ainsi, lors du changement de document, la complétion n'est pas mise à jour, et n'est donc pas pertinente. Enfin, on perd les précédentes données de complétion lors du parsing d'un autre document. Conserver ces données éviterai des parsing redondants.

\section{Intégration d'une recherche à plusieurs documents}

L'étape suivante a été l'intégration de la complétion pour tous les documents ouverts dans LaTeXiLa. Ceci pose plusieurs problèmes : comment proposer la complétion liée au document courant ? (problème de filtrage et de mise à jour des données) ; comment stoker ces différents ensembles de choix de complétion ?

Ceci nous a conduit à rechercher une structure de donnée adaptée, et à l'implémenter, après avoir étudié la documentation de ces structures dans le langage vala. Nous avons décidé d'utiliser un ensemble non redondant (HashSet) de choix de complétion, pour chaque document, qui est ensuite envoyé au gestionnaire de complétion. Nous avons doté celui-ci d'une table de hachage, ayant pour clef le chemin absolu d'un document, et comme valeur l'ensemble non redondant de choix de complétion associé. 

Les choix de complétion proposés à l'utilisateur sont ceux du document courant, et sont obtenus grâce à une méthode parcourant la table de hachage, et retournant l'ensemble des choix de complétion à proposer. Ceux-ci sont mis à jour lors de l'appel de l'utilisateur au gestionnaire de complétion. Lors du changement de document, ces choix sont mis à jour automatiquement dans le gestionnaire de complétion.

Désormais, l'ajout d'un choix de complétion est fait dans l'attribut du document précédement mentionné, au lieu de mettre à jour directement les choix de complétion du gestionnaire de complétion. La mise à jour de la table de hachage du gestionnaire de complétion est faite lorsque le parsing du document est terminé. Celui-ci a lieu lors de la sauvegarde du document par l'utilisateur, et lors de son ouverture dans LaTeXila.

\subsection{Structure de donnée}

\begin{lstlisting}[frame=single]
public class Document : Gtk.SourceBuffer
{
    // Référence vers le gestionnaire de complétion
    private CompletionProvider provider = CompletionProvider.getDefault();
    
    // Ensemble non redondant des choix de complétion associés à chaque label du document courant
    private Gee.HashSet<CompletionProvider.CompletionChoice?> _label_completion_choices = new Gee.HashSet<CompletionProvider.CompletionChoice?>();
    
    public void save(bool check_file_changed_on_disk = true; bool force = false)
    {
        // ...
        parse();
    }
}

public class CompletionProvider : GLib.Object, SourceCompletionProvider
{
    // Table de hachage regroupant tous les choix de complétion de chaque document
    private Gee.HashMap<string, Gee.HashSet<CompletionChoice?>> _labels_from_files = new Gee.HashMap<string, Gee.HashSet<CompletionChoice?>>();
    
    // Représente le dernier document analysé, donc le document courant
    private string _last_doc = "";
    
    // Permet de savoir s'il faut mettre à jour les choix de complétion proposés
    private bool _labels_modified = false;
    
    // Méthode déjà présente appellée lors de l'appel de l'utilisateur au gestionnaire de complétion
    public void populate (SourceCompletionContext context)
    {
        // ...
        if(_labels_modified)    // Uniquement si il faut mettre à jour les choix de complétion
            update_label_completion_choices();
    }
    
    public void update_label_completion_choices()
    {
        if(_last_doc != "") // Uniquement si la table de hachage contient quelque chose
        {
            CompletionChoice[] choices = get_all_labels(_last_doc);
            CompletionCommand cmd_ref = _commands["\\ref"];
            cmd_ref.args[0].choices = choices;
            _commands["\\ref"] = cmd_ref;
            set_labels_modified(true);
        }
    }
    
    public CompletionChoice[] get_all_labels(string doc)
    {
        CompletionChoice[] choices = {};
        
        foreach(var entry in _labels_from_files.entries)
        {
            if(entry.key.has_prefix(doc))
            {
                foreach(CompletionChoice c in entry.value)
                {
                    choices += c;
                }
            }
        }
    }
}

public class DocumentTab : Grid
{
    private cool view_focused_in ()
    {
        // ...
        document.load (document.location);    // Chargement du document, et analyse
    }
}
\end{lstlisting}

À ce stade, la complétion est fonctionnelle pour tous les fichiers ouverts, les données ne sont pas perdues, leur mise à jour est cohérente, et la mise à jour des choix de complétion du gestionnaire de complétion est faite de façon efficace. % dévelopepr ?
Cependant, il reste des problèmes : les choix de complétion ne contiennent que les labels déclarés dans le document courant, alors que le principe du langage \LaTeX{} est de permettre les références entre documents. Il faut donc revoir le filtrage des choix de complétion. Cet aspect nous conduit également à proposer des choix de complétion provenant de documents qui n'ont pas été ouverts.

\section{Intégration des fichiers non-ouverts}

Durant cette étape, nous avons répondu aux problèmes précédemment cités. Après discussion avec notre encadrant, nous avons décider de limiter les choix de complétion pour un document à l'ensemble des labels déclarés dans les documents .tex de son répertoire. Ce point est sujet à discussion, et nous y reviendrons par la suite. D'autre part, nous avons décidé de dissocier le parseur des labels du parseur de la structure du document, séparant ainsi ces deux aspects distincts.

Aussi, nous avons décidé de procéder de la façon suivante : à l'ouverture d'un document, on effectue l'analyse de ce document, puis de tous les documents .tex de son répertoire, s'ils n'ont pas déjà été analysé (cas de l'ouverture de plusieurs documents d'un même répertoire). De plus, le filtrage sur les choix de complétion à proposer est fait non plus sur le chemin absolu du document courant, mais sur celui de son répertoire parent. Nous avons approché ce problème de manière récursive, ce qui a conduit à certaines modifications.

Nous nous sommes donc intéressés à la notion de fichier en vala, et à leur manipulation.

\begin{lstlisting}[frame=single]
public class Document
{
    // Désormais, lors du chargement d'un document, on spécifie si l'on veut analyser ses frères, ou seulement ce document
    public void load(File location, bool parse_related)
    {
        // ...
        if(parse_related)
        {
            parse_related_documents();
        } else {
            parse();
        }
    }
    
    public void parse_related_documents()
    {
        File dir = location.getParent();    // Répertoire parent du document courant
        
        try {
            FileEnumerator enumerator = dir.enumerate_children(
                "standard::",
                FileQueryInfoFlags.NOFOLLOW_SYMLINKS,
                null);
            FileInfo info = null;
            
            while (((info = enumerator.next_file(null)) != null))
            {
                Document doc = new Document();
                File child = enumerator.get_child(info);
                string file_path = child.get_parse_name();
                if(file_path.has_suffix(".tex") && (!already_parsed(file_path)))    // S'il s'agit d'un document .tex, et qu'il n'a pas déjà été analysé, ie il n'y a pas d'entrée correspondante dans la table de hachage du gestionnaire de complétion
                {
                    doc.load(child, false); // On ne veut pas analyser les frères de ce document, cela est fait dans la boucle
                }
            }
            enumerator.close();
        } catch (Error e) {
            warning ("%s", e.message);
        }
    }
}

public class CompletionProvider : GLib.Object, SourceCompletionProvider
{
    // Remplace _last_doc
    // Représente le répertoire parent du dernier document analysé, donc du document courant
    private string _last_dir = "";
    
    // De la même façon, on remplace le filtrage par document par le filtrage par répertoire dans les méthodes update_label_completion_choices() et get_all_labels()
}
\end{lstlisting}

À ce stade, la complétion est entièrement fonctionnelle. Les choix proposés sont les labels déclarés dans les documents .tex du même répertoire que le document courant, l'analyse des documents est faite uniquement au besoin, et le changement de document courant vers un document d'un autre répertoire est fonctionnel.

Le mécanisme de complétion, auparavant \textit{statique} prend désormais en charge une complétion \textit{dynamique} sur les labels déclarés par l'utilisateur. Cependant, notre solution est notamment criticable sur le point suivant : le filtrage des choix de complétion proposés sur le répertoire parent du document courant. En effet, certains utilisateurs sont susceptibles d'utiliser des sous-répertoires pour organiser leurs fichiers, et ne bénéficieraient donc pas de la complétion souhaitée. De plus, il arrive que certains fichiers .tex ne soient que des anciennes versions de rapports, voire des fichiers de tests. Dans ce cas, notre mécanisme de complétion proposerait les labels déclarés dans ces fichiers, alors qu'ils ne sont pas souhaités.

Nous avons donc soumis ce patch au mainteneur du projet, monsieur Wilmet, qui nous as fait part de ses commentaires.

Après discussion avec notre encadrant et monsieur Wilmet, nous avons établi que pour palier à ces problèmes, une refonte de la notion de \textit{projet} comme ils sont organisés dans LaTeXiLa était nécessaire. On pourrait ainsi proposer une complétion ne prenant en compte que les fichiers faisant partie du même projet, et éviter les points précédemment soulevés.
\chapter{Conclusion}
Cette étude pratique a été pour nous l'occasion de découvrir le fonctionnement des projets open-source.

\end{document}
